Проект Push_swap - очень простой и очень эффективный алгоритм алгоритма: данные нужно будет отсортировать. В вашем распоряжении набор значений типа int, 2 стека и набор инструкций для управления обоими стеками.
Ваша цель? Напишите программу на языке C под названием push_swap, которая вычисляет и отображает в стандартном выводе самую маленькую программу, используя язык инструкций Push_swap, который сортирует полученные целочисленные аргументы.
Легкий?
Посмотрим ...

Написание алгоритма сортировки всегда является очень важным этапом в жизни программиста, потому что часто это первое знакомство с концепцией сложности.
Алгоритмы сортировки и их сложность являются частью классических вопросов, обсуждаемых во время собеседований. Вероятно, сейчас самое время взглянуть на эти концепции, потому что вам придется столкнуться с ними в какой-то момент.
Цели обучения этого проекта - строгость, использование C и использование базовых алгоритмов.
Особенно если посмотреть на сложность этих базовых алгоритмов.
Сортировка значений проста. Сортировка их наиболее быстрым способом менее проста, особенно потому, что от одной конфигурации целых чисел к другой наиболее эффективный алгоритм сортировки может различаться.

Этот проект будут исправлять только настоящие люди. Таким образом, вы можете свободно организовывать и называть свои файлы по своему усмотрению, хотя вам необходимо соблюдать некоторые требования, перечисленные ниже.
• Исполняемый файл должен называться push_swap.
• Вы должны отправить Makefile. Этот Makefile должен скомпилировать проект и содержать обычные правила. Он может только перекомпилировать программу при необходимости.
• Если вы умен, вы будете использовать свою библиотеку для этого проекта, отправьте также свою папку libft, включая собственный Makefile в корне вашего репозитория. Ваш Makefile должен будет скомпилировать библиотеку, а затем скомпилировать ваш проект.
• Глобальные переменные запрещены.
• Ваш проект должен быть написан на C в соответствии с Нормой.
• Вы должны деликатно обращаться с ошибками. Ни в коем случае ваша программа не может завершиться неожиданным образом (ошибка сегментации, ошибка шины, двойное освобождение и т. Д.).
• Ни одна из программ не может иметь утечек памяти.
• В рамках обязательной части вам разрешено использовать следующие функции:
◦ write
◦ read
◦ malloc
◦ free
◦ exit

Обязательная часть
V.1 Правила игры
• Игра состоит из 2 стеков, названных a и b.
• Начать с:
◦ a содержит случайное число положительных или отрицательных чисел без дубликатов.
◦ b пусто
• Цель состоит в том, чтобы отсортировать числа в порядке возрастания в стек a.
• Для этого в вашем распоряжении следующие операции:
sa: swap a - поменять местами первые 2 элемента на вершине стека a. Ничего не делать, если есть только один элемент или нет).
sb: swap b - поменять местами первые 2 элемента наверху стека b. Ничего не делать, если есть только один элемент или нет).
ss: sa и sb одновременно.
pa: push a - возьмите первый элемент вверху b и поместите его вверху a. Ничего не делать, если b пусто.
pb: push b - возьмите первый элемент вверху a и поместите его вверху b. Ничего не делать, если a пусто.
ra: rotate a - сдвинуть вверх все элементы стека a на 1. Первый элемент становится последним.
rb: rotate b - сдвинуть вверх все элементы стека b на 1. Первый элемент становится последним.
rr: ra и rb одновременно.
rra: reverse rotate a - сдвинуть вниз все элементы стека a на 1. Последний элемент становится первым.
rrb: reverse rotate b - сдвинуть вниз все элементы стека b на 1. Последний элемент становится первым.
rrr: rra и rrb одновременно.

V.3 Программа «push_swap»
• Вы должны написать программу с именем push_swap, которая будет получать в качестве аргумента стек, отформатированный как список целых чисел. Первый аргумент должен быть наверху стека (будьте осторожны с порядком).
• Программа должна отображать наименьший возможный список инструкций для сортировки стека a, причем наименьшее число должно быть вверху.
• Инструкции должны разделяться символом «\ n» и ничем другим.
• Цель состоит в том, чтобы отсортировать стек с минимально возможным количеством операций.
Во время защиты мы сравним количество инструкций, найденных вашей программой, с максимально допустимым количеством операций. Если ваша программа отображает слишком большой список или список не отсортирован должным образом, вы не получите баллов.
• В случае ошибки вы должны отобразить ошибку, за которой следует '\ n' для стандартной ошибки.
К ошибкам относятся, например: некоторые аргументы не являются целыми числами, некоторые аргументы больше целого числа и / или есть дубликаты.




Напишите программу с именем checker, которая получит в качестве аргумента стек, отформатированный как список целых чисел. Первый аргумент должен быть наверху стека
(будьте внимательны с порядком). Если аргумент не задан, проверка останавливается и ничего не отображает.
• Checker будет ждать и читать инструкции на стандартном вводе, за каждой инструкцией будет следовать ’\ n’. Как только все инструкции будут прочитаны, программа проверки выполнит их в стеке, полученном в качестве аргумента.
• Если после выполнения этих инструкций стек a фактически отсортирован, а b пуст, тогда программа проверки должна отобразить на стандартном выводе «OK», за которым следует a ’\ n’. Во всех остальных случаях программа проверки должна отображать «KO» с последующим «\ n» на стандартном выходе.
• В случае ошибки вы должны отобразить ошибку, за которой следует '\ n' для стандартной ошибки.
К ошибкам относятся, например: некоторые аргументы не являются целыми числами, некоторые аргументы больше целого числа, есть дубликаты, инструкция не существует и / или имеет неправильный формат.

Вы НЕ ОБЯЗАНЫ воспроизводить то же поведение, что и двоичный файл, который мы вам предоставляем. Обработка ошибок является обязательной, но решать вам, как вы решите анализировать аргументы.

Благодаря программе проверки вы сможете проверить, действительно ли список инструкций, которые вы создадите с помощью программы push_swap, правильно сортирует стек.